/*The NPC Class handles the spawning and movement of all NPCs*/package{	import flash.display.*	import flash.events.*		public class NPC extends MovieClip	{		//the list is an array of all items on stage		static public var list:Array= [];		static public var npcFlags:Array;		static public var main;		static public var iMarker:int; //used to reference a mouseevent object against the list of objects 						public function NPC(x_, y_, iType:int)		{			main=this;			//add the item to the list of all items			list.push(this);			//set iType (item type)			gotoAndStop(iType);			x = x_;			y = y_;			npcHit.mouseEnabled=false;			npcHit.alpha=0;			hitArea=npcHit; //for collisions			if (!npcFlags){populateFlags();}			//add event listeners for mouse up and down			addEventListener(MouseEvent.MOUSE_DOWN, dragDropDn);			addEventListener(MouseEvent.MOUSE_UP, dragDropUp);			addEventListener(MouseEvent.ROLL_OVER, npcOver);			addEventListener(MouseEvent.ROLL_OUT, npcOut);		}				public function populateFlags(){			npcFlags = new Array(new Array(8), new Array(8), new Array(8), new Array(8), new Array(8), new Array(8), new Array(8), new Array(8));			var i = 0;			var h = 0;			while (i != 8)			{				while (h != 8)				{					npcFlags[i][h] = 0; 					h++;				}				h=0;				i++;			}		}				public function dragDropDn(e:MouseEvent)		{			var object = e.target;			for(var i:int=0; i<list.length; i++) //check to see which item was drug			{				if (object == list[i]){ //items match					iMarker = i;					trace ("*NPC: imarker: " + iMarker);				}			}		}				public function dragDropUp(e:MouseEvent)		{			var obj = e.target;			//add in dialog start here			if (Item.isDragging == true){				trace ("*NPC: dragddropup: isdragging=true");				Item.main.stopItem(Item.list[Item.iMarker], e.stageY);				Item.main.placeItems(Item.list[Item.iMarker]);				if (Item.lastNPCType == list[iMarker].currentFrame){					if (testDrop(Item.lastItemType, Item.lastNPCType) == false){return;}					Item.lastNPCType = 0;				}			}			if (Tooltip.dialogOn == true || Tooltip.delay == true){Tooltip.curStep++;Tooltip.main.drawDialog(Tooltip.curNPC, Map.main.currentFrame);return;}			Tooltip.dialogOn = true;			Tooltip.curStep = 1;			Tooltip.curNPC = list[iMarker].currentFrame;			Tooltip.main.drawDialog(Tooltip.curNPC, Map.main.currentFrame)		}				public function npcOver(e:MouseEvent){			var obj = e.target;			var tempTip:String;			tempTip = Tooltip.main.translateNPCs(obj.currentFrame, Map.main.currentFrame);			if (tempTip != "x"){Tooltip.main.displayText(tempTip);}		}				public function npcOut(e:MouseEvent){			Tooltip.main.clearText();		}				public function testDrop(iType:int, npcType:int){			switch (Map.main.currentFrame){				case 21:					if (iType == 3){return true;}				case 24:					if (iType == 6){return true;}				default:					return false;			}		}				public function hideNPCs(){ //hides all items in item bar			for(var i:int=0; i<NPC.list.length; i++) //check for collisions with all items			{					NPC.list[i].visible=false;			}		}				public function showNPCs(){ //shows all items in item bar			for(var i:int=0; i<NPC.list.length; i++) //check for collisions with all items			{					NPC.list[i].visible=true;			}		}				public function findNPCs(npcType:int){ //shows all items in item bar			for(var i:int=0; i<NPC.list.length; i++) //check for collisions with all items			{					if (NPC.list[i].currentFrame == npcType){						return i;					}			}			return 0;		}				public function spawnNPCs(x_,y_, iType){ //mostly for use from other classes			MM.main.npc = new NPC(x_, y_, iType);			MM.main.spriteClip.addChild(MM.main.npc);		}				public function removeNPCs(){ //used to remove all items that aren't in the inventory			var i:int=0;			while(i<list.length) //check for collisions with all items			{				list[i].removeEventListener(MouseEvent.MOUSE_DOWN, dragDropDn);				list[i].removeEventListener(MouseEvent.MOUSE_UP, dragDropUp);				list[i].removeEventListener(MouseEvent.ROLL_OVER, npcOver);				list[i].removeEventListener(MouseEvent.ROLL_OUT, npcOut);				//remove my grpahic from the stage				MM.main.spriteClip.removeChild(list[i]);				list.splice(i,1);			}					}						//this method will destory all items in the item list		static public function killAll()		{			//keep killing the fisrt item in the list until the list is empty			while(list.length>0)			{				list[0].kill();			}		}				//this method will kill this item instance		public function kill()		{			trace ("*NPC: finding [" + Tooltip.main.translateNPCs(this.currentFrame, false) + "(" + this.currentFrame + ")]");			for(var i:int = 0;i < list.length; i++)			{				trace ("*NPC: kill(list): i:" + i + "/" + list.length + " - currentFrame:" + list[i].currentFrame);				//if this list index is me				if(list[i] == this)				{					// remove me from the item list					trace ("*NPC: kill(splice): i:" + i + "/" + list.length + " - currentFrame:" + list[i].currentFrame);					list.splice(i,1);				}			}			//remove my mouse events			removeEventListener(MouseEvent.MOUSE_DOWN, dragDropDn);			removeEventListener(MouseEvent.MOUSE_UP, dragDropUp);			removeEventListener(MouseEvent.ROLL_OVER, npcOver);			removeEventListener(MouseEvent.ROLL_OUT, npcOut);			//remove my grpahic from the stage			MM.main.spriteClip.removeChild(this);			trace ("*NPC: kill(done)");		}	}}