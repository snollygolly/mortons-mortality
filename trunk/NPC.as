/*The NPC Class handles the spawning and movement of all NPCsit also has "testDrop" that determines if item drops on specific npcs should trigger dialog*/package{	import flash.display.*	import flash.events.*	import flash.utils.Timer;		public class NPC extends MovieClip	{		//the list is an array of all items on stage		static public var list:Array= [];		static public var npcFlags:Array;		static public var main;		static public var iMarker:int; //used to reference a mouseevent object against the list of objects 				static public var moveDir:String;		static public var moving:Boolean = false;		static public var movingNPC:MovieClip;		static public var cSix:int = 0; //6 count, moves every 6 frames		static public var wanderTimer:Timer = new Timer(5000, 60);;						public function NPC(x_, y_, iType:int) //itype = npc type		{			main=this;			//add the npc to the list of all npcs			list.push(this);			gotoAndStop(iType);			x = x_;			y = y_;			npcHit.mouseEnabled=false;			npcHit.alpha=0;			hitArea=npcHit; //for collisions			if (!npcFlags){populateFlags();} //npc flags are used to track progress in the game			//add event listeners for mouse up and down			addEventListener(MouseEvent.MOUSE_DOWN, dragDropDn);			addEventListener(MouseEvent.MOUSE_UP, dragDropUp);			addEventListener(MouseEvent.ROLL_OVER, npcOver);			addEventListener(MouseEvent.ROLL_OUT, npcOut);			if (list.length == 1){				addEventListener(Event.ENTER_FRAME, enterFrame);				//wanderTimer:Timer = new Timer(5000, 60);				wanderTimer.addEventListener(TimerEvent.TIMER, wanderNPC);				wanderTimer.start();				wanderNPC(null);			}		}				public function populateFlags(){ //fill all npc flags with 0's			npcFlags = new Array(new Array(8), new Array(8), new Array(8), new Array(8), new Array(8), new Array(8), new Array(8), new Array(8));			var i = 0;			var h = 0;			while (i != 8)			{				while (h != 8)				{					npcFlags[i][h] = 0; 					h++;				}				h=0;				i++;			}		}				public function dragDropDn(e:MouseEvent)		{			var object = e.target;			for(var i:int=0; i<list.length; i++) //check to see which npc was moused			{				if (object == list[i]){ //objects match					iMarker = i;					trace ("*NPC: imarker: " + iMarker);				}			}		}				public function dragDropUp(e:MouseEvent)		{			var obj = e.target;			for(var i:int=0; i<list.length; i++) //check to see which npc was moused			{				if (obj == list[i]){ //objects match					iMarker = i;					trace ("*NPC: imarker: " + iMarker);				}			}			//add in dialog start here			if (Item.isDragging == true){ //if you're dropping an item on the npc				trace ("*NPC: dragddropup: isdragging=true");				Item.main.stopItem(Item.list[Item.iMarker], e.stageY); //stop the item				Item.main.placeItems(Item.list[Item.iMarker]); //put it back in your inventory				if (Item.lastNPCType == list[iMarker].currentFrame){ //if you were currently dragging an item					if (testDrop(Item.lastItemType, Item.lastNPCType) == false){return;}  //see if the drop should trigger dialog					Item.lastNPCType = 0; //reset var				}			}			if (Tooltip.dialogOn == true || Tooltip.delay == true){Tooltip.curStep++;Tooltip.main.drawDialog(list[iMarker].currentFrame, Map.main.currentFrame);return;} //if dialog isn't on and we aren't fading text, start dialog			Tooltip.dialogOn = true; //otherwise, assume it's your initial click			Tooltip.curStep = 1; //set the step to 1			Tooltip.curNPC = list[iMarker].currentFrame; //store the npc type			Tooltip.main.drawDialog(Tooltip.curNPC, Map.main.currentFrame) //go go gadget dialog!		}				public function npcOver(e:MouseEvent){			var obj = e.target;			var tempTip:String;			tempTip = Tooltip.main.translateNPCs(obj.currentFrame, Map.main.currentFrame, true); //display tooltip on NPC (if any)			if (tempTip != "x"){				if (obj.currentFrame != 8){Tooltip.main.displayText(tempTip + "\n(click to talk)");}else{Tooltip.main.displayText(tempTip + "\n(click to squash)");}			} // "x" if no tooltip		}				public function npcOut(e:MouseEvent){			Tooltip.main.clearText();		}				public function testDrop(iType:int, npcType:int){ //see if item drops should trigger dialog			switch (Map.main.currentFrame){				case 1: //fake map frames, remove if enabling drag drop items on people.					if (iType == 3){return true;}				case 2:					if (iType == 6){return true;}				default:					return false;			}		}				public function findNPCs(npcType:int){ 			for(var i:int=0; i<NPC.list.length; i++) 			{					if (NPC.list[i].currentFrame == npcType){ //if specified npc matches, return true						return i;					}			}			return 0;		}				public function moveNPC(target:MovieClip, dir:String, dur:int){			movingNPC = target;			moveDir = dir;			moving = true;			var myTimer:Timer = new Timer(dur, 1);			myTimer.addEventListener(TimerEvent.TIMER, stopNPC);			myTimer.start();		}				public function enterFrame(e:Event){			//trace ("*NPC: enter frame:", moving,checkAssets(),checkMorton(),checkSelf());			if (moving == true && Tooltip.dialogOn == false){				var offset:int = 0;				var npcName:String = Tooltip.main.translateNPCs(movingNPC.currentFrame, 0, false);				npcName = npcName.toLowerCase();				switch (moveDir){					case "n":						movingNPC.y -= MM.NPCSPEED;						offset = 6;						if (checkAssets() == true || checkSelf() == true){moveDir = "s";offset = 9;movingNPC[npcName].gotoAndStop(movingNPC[npcName].currentFrame + 3);}						break;					case "s":						movingNPC.y += MM.NPCSPEED;						offset = 9;						if (checkAssets() == true || checkSelf() == true){moveDir = "n";offset = 6;movingNPC[npcName].gotoAndStop(movingNPC[npcName].currentFrame - 3);}						break;					case "w":						movingNPC.x -= MM.NPCSPEED;						offset = 3;						if (checkAssets() == true || checkSelf() == true){moveDir = "e";offset = 0;movingNPC[npcName].gotoAndStop(movingNPC[npcName].currentFrame - 3);}						break;					case "e":						movingNPC.x += MM.NPCSPEED;						if (checkAssets() == true || checkSelf() == true){moveDir = "w";offset = 3;movingNPC[npcName].gotoAndStop(movingNPC[npcName].currentFrame + 3);}						break;				}				if (checkMorton() == true){stopNPC(null);return;}				if (cSix == 0){//first frame for animation					movingNPC[npcName].gotoAndStop(offset + 1);					cSix = 1;					return;				}				if (cSix == 6){					cSix = 1;					if ((movingNPC[npcName].currentFrame - offset) == 3){						movingNPC[npcName].gotoAndStop(offset + 1);					}					else {						movingNPC[npcName].gotoAndStop(movingNPC[npcName].currentFrame + 1);					}				}else{cSix++;}			}		}				public function checkAssets()		{			for(var i:int=0; i<Asset.list.length; i++) //check for collisions with all items			{					if (this.hitArea.hitTestObject(Asset.list[i].hitArea) && this != list[i])					{						return true;					}			}			return false;		}				public function checkMorton()		{			if (this.hitArea.hitTestObject(Morton.main.hitArea))			{				return true;			}			return false;		}				public function checkSelf() //lest you wreck self		{			if (this.x > Map.eb || this.x < Map.wb || this.y < Map.nb || this.y > Map.sb ) 			{				return true;			}			return false;		}				public function stopNPC(event:TimerEvent):void{			var offset:int = 0;			switch (moveDir){				case "n":					offset = 6;					break;				case "s":					offset = 9;					break;				case "w":					offset = 3					break;			}			var npcName:String = Tooltip.main.translateNPCs(movingNPC.currentFrame, 0, false);			npcName = npcName.toLowerCase();			movingNPC[npcName].gotoAndStop(offset + 1);			moving = false;			cSix = 0;		}				public function wanderNPC(event:TimerEvent):void{			var randDir:int = MM.main.randomNumber(1,4);			//trace ("*npc:wander:rand:",randDir, MM.mmCounter);			var randNPC:int = MM.main.randomNumber(1, list.length);			randNPC--;			var lBound:int = 500;			var hBound:int = 2000;			if (list[randNPC].currentFrame == 8){lBound = 3000;hBound=4500;}			var randTime:int = MM.main.randomNumber(lBound, hBound);			if (list[randNPC].currentFrame == 1){return;}						switch (randDir){				case 1:					moveNPC(list[randNPC],"w", randTime);					break;				case 2:					moveNPC(list[randNPC],"n", randTime);					break;				case 3:					moveNPC(list[randNPC],"w", randTime);					break;				case 4:					moveNPC(list[randNPC],"n", randTime);					break;			}		}				public function spawnNPCs(x_,y_, iType){ //mostly for use from other classes			MM.main.npc = new NPC(x_, y_, iType);			MM.main.spriteClip.addChild(MM.main.npc);		}				public function kill()		{			trace ("*NPC: finding [" + Tooltip.main.translateNPCs(this.currentFrame,0, false) + "(" + this.currentFrame + ")]");			for(var i:int = 0;i < list.length; i++)			{				trace ("*NPC: kill(list): i:" + i + "/" + list.length + " - currentFrame:" + list[i].currentFrame);				//if this list index is me				if(list[i] == this)				{					// remove me from the item list					trace ("*NPC: kill(splice): i:" + i + "/" + list.length + " - currentFrame:" + list[i].currentFrame);					list.splice(i,1);				}			}			//remove my mouse events			if (list.length == 0){wanderTimer.stop();removeEventListener(Event.ENTER_FRAME, enterFrame);}			removeEventListener(MouseEvent.MOUSE_DOWN, dragDropDn);			removeEventListener(MouseEvent.MOUSE_UP, dragDropUp);			removeEventListener(MouseEvent.ROLL_OVER, npcOver);			removeEventListener(MouseEvent.ROLL_OUT, npcOut);						//remove my grpahic from the stage			MM.main.spriteClip.removeChild(this);			trace ("*NPC: kill(done)");		}				public function removeNPCs(){ //used to remove all items that aren't in the inventory			var i:int=0;			while(i<list.length) //check for collisions with all items			{				wanderTimer.stop();				list[i].removeEventListener(MouseEvent.MOUSE_DOWN, dragDropDn);				list[i].removeEventListener(MouseEvent.MOUSE_UP, dragDropUp);				list[i].removeEventListener(MouseEvent.ROLL_OVER, npcOver);				list[i].removeEventListener(MouseEvent.ROLL_OUT, npcOut);				list[i].removeEventListener(Event.ENTER_FRAME, enterFrame);				//remove my grpahic from the stage				MM.main.spriteClip.removeChild(list[i]);				list.splice(i,1);			}					}	}}